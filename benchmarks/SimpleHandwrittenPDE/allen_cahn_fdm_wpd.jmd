---
title: Allen-Cahn Finite-Difference Method Work-Precision Diagrams
author: Arjit Seth
---

## Equations

The Allen-Cahn PDE is posed as follows:
```math
\begin{align}
   \partial_t u = \gamma \nabla^2 u - u^3 + u \\
\end{align}
```
This is discretized in space via the finite difference method:
```math
\begin{align}
    \partial_t u = \gamma D_x^2 u - u^3 + u
\end{align}
```

## Packages

```julia
using OrdinaryDiffEq
using DiffEqDevTools
using SciMLOperators
using LinearSolve
using LinearAlgebra
using SparseArrays
using Plots
gr();
```

## Implementation

```julia
# Linear term: Second derivative
function linear_term(N, dx, nu)
    # Second derivative operator (-u_xx)
    e = ones(N + 1)
    D2 = spdiagm(1 => e[1:end-1], 0 => -2e, -1 => e[1:end-1])
    # Periodic boundary conditions
    # D2[1, end] = 1.0 # Left ghost cell
    # D2[end, 1] = 1.0 # Right ghost cell
    D2 /= dx^2 # Central difference

    return nu * D2
end

# Nonlinear term: u - u^3
function nonlinear_term(alpha)
    function (du, u, p, t)
        du .= alpha * (u .- u .^ 3)
    end
end

function apply_boundary_conditions!(u, u_start, u_end)
    u[1] = u_start 
    u[end] = u_end

    return u
end

# Construct the problem
function allen_cahn(N, L)
    # Discretization
    x = LinRange(-L, L, N + 1)
    dx = x[2] - x[1]

    # Linear and nonlinear terms
    nu = 4.0 # Diffusion coefficient
    alpha = 4.0 # Nonlinear coefficient
    f1 = linear_term(N, dx, nu)
    f2 = nonlinear_term(alpha)

    u0 = @. cos(2Ï€ * x) # Initial condition
    
    # Apply boundary conditions
    fb1(du, u, p, t) = MatrixOperator(f1)(du, apply_boundary_conditions!(u, u[1], u[end]), p, t)
    fb2(du, u, p, t) = f2(du, apply_boundary_conditions!(u, u[1], u[end]), p, t)
    
    prob = SplitODEProblem(fb1, fb2, u0, (0.0, 1.0))

    x, prob
end;
```

## Reference Solution

```julia
N = 128 # Number of grid points
L = 2.0  # Domain length
xs, prob = allen_cahn(N, L)
# @time sol = solve(prob, AutoVern7(RadauIIA5(autodiff=false)); dt=1e-2, abstol=1e-14, reltol=1e-14, adaptive=true)
@time sol = solve(prob, Tsit5(); abstol=1e-14, reltol=1e-14, adaptive=true)

tslices = LinRange(prob.tspan..., 50)
ys = mapreduce(sol, hcat, tslices)
plt = heatmap(xs, tslices, ys', xlabel="x", ylabel="t")
```

## Work-Precision Diagrams

```julia
test_sol = TestSolution(sol); 

abstols = 0.1 .^ (5:7) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:3)
multipliers = 0.5 .^ (0:3)
setups = [
    Dict(:alg => IMEXEuler(), :dts => 1e-4 * multipliers),
    Dict(:alg => CNAB2(), :dts => 1e-4 * multipliers),
    # Dict(:alg => CNLF2(), :dts => 1e-2 * multipliers), # Convergence fails
    Dict(:alg => SBDF2(), :dts => 1e-4 * multipliers)
]
labels = hcat(
    "IMEXEuler",
    "CNAB2",
    # "CNLF2",
    "SBDF2",

)
@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Int(1e5));

plot(wp, label=labels, markershape=:auto, title="Work-Precision Diagram, High Tolerance")
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
