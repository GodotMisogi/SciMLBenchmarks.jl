---
title: Allen-Cahn Pseudospectral Methods Work-Precision Diagrams
author: Arjit Seth
---


### Problem Description

The following initial-boundary-value problem is considered for the Allen-Cahn equation in one dimension:
```math
\begin{aligned}
    \frac{\partial}{\partial t} u(x,t) & = \epsilon^2 \frac{\partial^2}{\partial x^2} u(x,t) + u(x,t) - u^3(x,t) \\
    u(x,0) & = \cos(2\pi x), \quad x \in [-1, 1] \end{aligned}
```
The equations are discretized in space via pseudospectral methods. Specifically, the Chebyshev basis is used to represent the solution in space:
```math
\begin{aligned}
    u(x,t) & = \sum_{k=0}^{n-1} c_k(t) T_k(x) \\
    \frac{\partial^2}{\partial x^2} u(x,t) & = \sum_{k=0}^{n-1} c_k(t) \frac{d^2}{dx^2} T_k(x) \\
    \frac{\partial}{\partial t} u(x,t) & = \sum_{k=0}^{n-1} \dot{c}_k(t) T_k(x)
\end{aligned}
```

### Implementation

```julia
using OrdinaryDiffEq
using DiffEqDevTools
using SciMLOperators
using LinearSolve
using LinearAlgebra
using SparseArrays
using ClassicalOrthogonalPolynomials
using Plots
gr();
```

```julia
# Nonlinear component of vector field
function f_nonlinear!(du, u, p, t)
    M, D0, alpha, tmp = p
    Tu = D0 * u # Pseudo-spectral representation of solution
    @. tmp[2:end-1] = alpha * (Tu - Tu^3) 
    ldiv!(du, M, tmp) # Solve the linear system M * du = tmp
end

function make_allen_cahn(n, eps)
    T = ChebyshevT() # Chebyshev basis
    x1 = reverse(ChebyshevGrid{1}(n - 2)) # 1st kind points, sorted
    x2 = reverse(ChebyshevGrid{2}(n)) # 2nd kind points, sorted

    V = T[x2, 1:n] # Vandermonde matrix, its inverse is transform from values to coefficients
    D0 = diff(T, 0)[x1, 1:n] / V # discretisation of identity matrix
    D2 = diff(T, 2)[x1, 1:n] / V # 2nd derivative from x2 to x1

    B_l = [1; zeros(n-1)]'  # Left Dirichlet conditions
    B_r = [zeros(n-1); 1]'  # Right Dirichlet
    M = lu([B_l; D0; B_r]) # Mass matrix for the problem
    u0 = cos.(2π * x2)  # Initial condition
    alpha = 3.0 # Lipschitz constant scaling factor
    D2_bc = [zeros(1, n); D2; zeros(1, n)] # 2nd derivative with Dirichlet conditions

    # Problem setup
    prob = SplitODEProblem(
        MatrixOperator(eps * (M \ D2_bc)), # Linear operator with mass matrix inversion
        f_nonlinear!,
        u0, (0.0, 1.0),
        (M, D0, alpha, similar(u0))
    )

    return x2, prob
end
```

## Reference Solution

```julia
N = 128
ε = 1e-3
xs, prob = make_allen_cahn(N, ε);

@time sol = solve(prob, Rodas5(autodiff=false); dt=1e-4, reltol=1e-12, abstol=1e-12);

test_sol = TestSolution(sol); # Reference solution for error estimation

tslices = LinRange(prob.tspan..., 50)
ys = mapreduce(sol, hcat, tslices)
heatmap(xs, tslices, ys', xlabel="x", ylabel="t")
```

## Work-Precision Diagrams

### Implicit-Explicit Methods

```julia
abstols = 0.1 .^ (5:8) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:4)
multipliers = 0.5 .^ (0:4)
setups = [
    Dict(:alg => IMEXEuler(), :dts => 1e-4 * multipliers),
    Dict(:alg => CNAB2(), :dts => 1e-4 * multipliers),
    Dict(:alg => CNLF2(), :dts => 1e-4 * multipliers),
    Dict(:alg => SBDF2(), :dts => 1e-4 * multipliers)
]
labels = hcat(
    "IMEXEuler",
    "CNAB2",
    "CNLF2",
    "SBDF2",
)
@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Int(1e5));

plot(wp, label=labels, markershape=:auto, title="Work-Precision Diagram, High Tolerance")
```

### Exponential Integrators

```julia
abstols = 0.1 .^ (5:8) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:4)
multipliers = 0.5 .^ (0:4)
setups = [
    Dict(:alg => NorsettEuler(), :dts => 1e-4 * multipliers),
    Dict(:alg => NorsettEuler(krylov=true, m=5), :dts => 1e-4 * multipliers),
    Dict(:alg => NorsettEuler(krylov=true, m=20), :dts => 1e-4 * multipliers),
    Dict(:alg => ETDRK2(), :dts => 1e-4 * multipliers),
    Dict(:alg => ETDRK2(krylov=true, m=20), :dts => 1e-4 * multipliers),
    Dict(:alg => ETDRK2(krylov=true, m=20), :dts => 1e-4 * multipliers)
]
labels = hcat(
    "NorsettEuler (caching)", 
    "NorsettEuler (m=5)",
    "NorsettEuler (m=20)",
    "ETDRK2 (caching)", 
    "ETDRK2 (m=5)", 
    "ETDRK2 (m=20)"
)
@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Int(1e5));

plot(wp, label=labels, markershape=:auto, title="ExpRK methods, low order")
```

### Explicit Methods

```julia
abstols = 0.1 .^ (5:7) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:3)
multipliers = 0.5 .^ (0:4)
setups = [
    Dict(:alg => RK4(), :dts => 1e-4 * multipliers),
    Dict(:alg => Tsit5(), :dts => 1e-4 * multipliers),
    Dict(:alg => Vern7(), :dts => 1e-4 * multipliers)
]
labels = hcat(
    "RK4",
    "Tsit5",
    "Vern7",
)
@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Int(1e5));

plot(wp, label=labels, markershape=:auto, title="Work-Precision Diagram, High Tolerance")
```


### Between Family Comparisons

```julia
abstols = 0.1 .^ (5:8) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:4)
multipliers = 0.5 .^ (0:3)
setups = [
    Dict(:alg => CNAB2(), :dts => 1e-4 * multipliers),
    Dict(:alg => CNAB2(linsolve=KrylovJL_GMRES()), :dts => 1e-4 * multipliers),
    Dict(:alg => ETDRK2(), :dts => 1e-4 * multipliers),
]
labels = hcat(
    "CNAB2 (dense linsolve)",
    "CNAB2 (Krylov linsolve)", 
    "ETDRK2 (m=5)",
)
@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Int(1e5));

plot(wp, label=labels, markershape=:auto, title="Between family, low orders")
```


```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
