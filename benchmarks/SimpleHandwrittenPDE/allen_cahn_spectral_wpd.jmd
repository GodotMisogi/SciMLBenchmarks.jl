---
title: Allen-Cahn Pseudospectral Methods Work-Precision Diagrams
author: Arjit Seth
---


### Problem Description

The following initial-boundary-value problem is considered for the Allen-Cahn equation in one dimension:
```math
\begin{aligned}
    \frac{\partial}{\partial t} u(x,t) & = \epsilon^2 \frac{\partial^2}{\partial x^2} u(x,t) + u(x,t) - u^3(x,t) \\
    u(x,0) & = \cos(2\pi x), \quad x \in [-1, 1] \end{aligned}
```
The equations are discretized in space via pseudospectral methods. Specifically, the Chebyshev basis is used to represent the solution in space:
```math
\begin{aligned}
    u(x,t) & = \sum_{k=0}^{n-1} c_k(t) T_k(x) \\
    \frac{\partial^2}{\partial x^2} u(x,t) & = \sum_{k=0}^{n-1} c_k(t) \frac{d^2}{dx^2} T_k(x) \\
    \frac{\partial}{\partial t} u(x,t) & = \sum_{k=0}^{n-1} \dot{c}_k(t) T_k(x)
\end{aligned}
```

### Implementation

```julia
using OrdinaryDiffEq
using DiffEqDevTools
using SciMLOperators
using LinearSolve
using LinearAlgebra
using SparseArrays
using ClassicalOrthogonalPolynomials
using Plots
gr();
```

```julia
# DAE vector field
function f_nonlinear!(du, u, p, t)
    D0, eD2, alpha = p
    du[1] = 0. # u[1]  # left boundary condition
    du[2:end-1] .= alpha * (eD2 * u + D0 * (u - u.^3))
    du[end] = 0. # u[end]  # right boundary condition
end

function make_allen_cahn(n, eps)
    T = ChebyshevT() # Chebyshev basis
    x₁ = reverse(ChebyshevGrid{1}(n - 2)) # 1st kind points, sorted
    x₂ = reverse(ChebyshevGrid{2}(n)) # 2nd kind points, sorted

    V = T[x₂, 1:n] # Vandermonde matrix, its inverse is transform from values to coefficients
    D0 = diff(T, 0)[x₁, 1:n] / V # discretisation of identity matrix
    D2 = diff(T, 2)[x₁, 1:n] / V # 2nd derivative from x₂ to x₁

    u0 = cos.(2π * x₂)  # Initial condition
    B_l = [1; zeros(n-1)]'  # Left Dirichlet conditions
    B_r = [zeros(n-1); 1]'  # Right Dirichlet
    alpha = 10.0 # Lipschitz constant scaling factor

    # Problem setup
    prob = ODEProblem(
        ODEFunction(f_nonlinear!, mass_matrix = [B_l; D0; B_r]),
        u0, (0.0, 1.0),
        (D0, eps^2 * D2, alpha)  # Parameters: 2nd derivative operator and scaling factor
    )
    # prob = SplitODEProblem(MatrixOperator(), f_nonlinear!, u0, (0.0, 1.0))

    return x₂, prob
end
```

## Reference Solution

```julia
N = 128
ε = 0.02
xs, prob = make_allen_cahn(N, ε);

@time sol = solve(prob, Rodas5(); dt=1e-4, reltol=1e-12, abstol=1e-12);

# %% Plotting
tslices = LinRange(prob.tspan..., 50)
ys = mapreduce(sol, hcat, tslices)
heatmap(xs, tslices, ys', xlabel="x", ylabel="t")

```

## Work-Precision Diagrams

```julia
test_sol = TestSolution(sol); # Reference solution for error estimation

abstols = 0.1 .^ (5:8) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:4)
multipliers = 0.5 .^ (0:3)
setups = [
    Dict(:alg => Rodas3(), :dts => 1e-4 * multipliers),
    Dict(:alg => Rodas4(), :dts => 1e-4 * multipliers),
    Dict(:alg => Rodas5(), :dts => 1e-4 * multipliers),
    Dict(:alg => GRK4T(), :dts => 1e-4 * multipliers),
    Dict(:alg => GRK4A(), :dts => 1e-4 * multipliers),
]
labels = hcat(
    "Rodas3",
    "Rodas4",
    "Rodas5",
    "GRK4T",
    "GRK4A",
)

@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Inf);

plot(wp, label=labels, 
    markershape=:auto, title="Work-Precision Diagram",
    legend=:topright, size=(800, 600))
```


```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
