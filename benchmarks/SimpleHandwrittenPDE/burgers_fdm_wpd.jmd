---
title: Burgers' Equation Finite-Difference Method Work-Precision Diagrams
author: Arjit Seth
---

The following initial-boundary-value problem is considered for Burgers' equation in one dimension:
```math
\begin{aligned}
    \frac{\partial}{\partial t} u(x,t) + \frac{\partial}{\partial x} u^2(x,t) & = \nu \frac{\partial^2}{\partial x^2} u(x,t) \\
    u(x,0) & = \cos(\cos(x-0.1))
\end{aligned}
```
The equations are discretized via finite differences.
```math
\begin{aligned}
    \frac{\partial}{\partial t} u_i(t) + \frac{u_{i
+1}^2(t) - u_{i-1}^2(t)}{2\Delta x} & = \nu \left(\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{\Delta x^2}\right) \\
    u_i(0) & = \cos(\cos(x_i-0.1)) \\
    \implies \frac{\partial}{\partial t} \mathbf u(t) & = D_1 \mathbf u(t) + D_2 \mathbf u(t) \\
    D_1 & = \frac{1}{2\Delta x} \begin{bmatrix}
    -1 & 1 & 0 & \cdots & 0 \\
    0 & -1 & 1 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \ddots & \vdots \\
    0 & 0 & \cdots & -1 & 1 \\
    0 & 0 & \cdots & 0 & -1
    \end{bmatrix} \\
    D_2 & = \frac{\nu}{\Delta x^2} \begin{bmatrix}
    -2 & 1 & 0 & \cdots & 0 \\
    1 & -2 & 1 & \cdots & 0 \\
    0 & 1 & -2 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \ddots & \vdots \\
    0 & 0 & \cdots & 1 & -2
    \end{bmatrix}
\end{aligned}
```
where the second term is the linear diffusion term and the first term is the nonlinear advection term.


```julia
using OrdinaryDiffEq
using DiffEqDevTools
using SciMLOperators
using LinearSolve
using LinearAlgebra
using SparseArrays
using Plots
gr();
```

```julia
# Linear term (second derivative)
function linear_term(N, dx, nu)
    e = ones(N + 1) # super diagonal
    D2 = spdiagm(-1 => e[1:end-1], 0 => -2e, 1 => e[1:end-1])
    D2 /= dx^2 # Central difference

    return nu * D2
end

# Nonlinear term (nonlinear convection)
function nonlinear_term(N, dx, alpha)
    # First derivative operator
    e = ones(N)
    D1 = spdiagm(1 => e, -1 => -e)
    # D1[1, end] = -1 # Left ghost cell
    # D1[end, 1] = 1  # Right ghost cell
    D1 /= 2dx # Central difference

    # Nonlinear convection term: -(u * u_x)
    # tmp = zeros(N + 1)
    function (du, u, p, t)
        # @. tmp = u^2s
        mul!(du, D1, u)
        @. du *= -alpha * u
    end
end

# Construct the problem
function burgers(N, L)
    x = LinRange(0, L, N + 1)
    dx = x[2] - x[1]

    nu = 1e-2 # Diffusion coefficient
    alpha = 1.0 # Convection coefficient
    f1 = linear_term(N, dx, nu)
    f2 = nonlinear_term(N, dx, alpha)

    μ0 = 0.5
    σ0 = 0.05
    u0 = @. exp(-(x - μ0)^2 / (2 * σ0^2)) # Initial condition
    prob = SplitODEProblem(MatrixOperator(f1), f2, u0, (0.0, 1.0))
    return x, prob
end;
```

Reference solution using Vern9 with adaptive time-stepping:

```julia
N = 128
L = 1.0
xs, prob = burgers(N, L)
sol = solve(prob, AutoVern7(Rodas5(autodiff=false)); abstol=1e-14, reltol=1e-14, adaptive=true)

tslices = LinRange(0.0, 1.0, 50)
ys = mapreduce(sol, hcat, tslices)
p = heatmap(xs, tslices, ys', xlabel="x", ylabel="t")
```

## Work-Precision Diagrams

```julia
test_sol = TestSolution(sol); # Reference solution for error estimation

abstols = 0.1 .^ (5:8) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:4)
multipliers = 0.5 .^ (0:3)
setups = [
    Dict(:alg => IMEXEuler(), :dts => 1e-3 * multipliers), 
    Dict(:alg => CNAB2(), :dts => 1e-2 * multipliers),
    Dict(:alg => CNLF2(), :dts => 1e-2 * multipliers),
    Dict(:alg => SBDF2(), :dts => 1e-3 * multipliers)
]
labels = hcat(
    "IMEXEuler", 
    "CNAB2",
    "CNLF2",
    "SBDF2",
)

@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Inf);

plot(wp, label=labels, 
    markershape=:auto, title="Work-Precision Diagram, High Tolerance",
    legend=:topright, size=(800, 600))
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
