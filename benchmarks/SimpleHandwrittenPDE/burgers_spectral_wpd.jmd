---
title: Burgers' Equation Pseudospectral Method Work-Precision Diagrams
author: Arjit Seth
---


The following initial-boundary-value problem is considered for Burgers' equation in one dimension:
```math
\begin{aligned}
    \frac{\partial}{\partial t} u(x,t) + \frac{\partial}{\partial x} u^2(x,t) & = \nu \frac{\partial^2}{\partial x^2} u(x,t) \\
    u(x,0) & = \exp\left(-\frac{(x - \mu_0)^2}{2 \sigma_0^2}\right), \quad \mu_0 = 0.0, \sigma_0 = 0.1, x \in [-1,] \\
\end{aligned}
```
The equations are discretized in space via pseudospectral methods. Specifically, the Chebyshev basis is used to represent the solution in space.
```math

```

```julia
using OrdinaryDiffEq
using DiffEqDevTools
using SciMLOperators
using LinearSolve
using LinearAlgebra
using SparseArrays
using ClassicalOrthogonalPolynomials
const COP = ClassicalOrthogonalPolynomials
using Plots
gr();
```

```julia
# DAE vector field
function burgers!(du, u, p, t)
    D₁, D₂, R, nu = p
    du[1] = u[1] # left bc
    mul!(@view(du[2:(end - 1)]), nu * D₂, u) # 2nd derivative excluding ghost cells
    # mul!(tmp, D₁, u) # 1st derivative excluding ghost cells
    @view(du[2:(end - 1)]) .-= (R * u) .* (D₁ * u) # currently allocating, pass temp
    du[end] = u[end] # right bc
end

# Constructor
function make_burgers(n)
    T = ChebyshevT() # Chebyshev basis
    x₁ = reverse(ChebyshevGrid{1}(n-2)) # 1st kind points, sorted
    x₂ = reverse(ChebyshevGrid{2}(n)) # 2nd kind points, sorted
    V = T[x₂, 1:n] # Vandermonde matrix, its inverse is transform from values to coefficients
    D₁ = diff(T, 1)[x₁, 1:n] / V # 1st derivative from x₂ to x₁
    D₂ = diff(T, 2)[x₁, 1:n] / V # 2nd derivative from x₂ to x₁
    R = T[x₁, 1:n] / V # discretisation of identity matrix

    μ0 = 0.0
    σ0 = 0.1
    u0 = @. exp(-(x₂ - μ0)^2 / (2 * σ0^2)) # Initial condition
    B_l = [1; zeros(n-1)]' # Left Dirichlet conditions
    B_r = [zeros(n-1); 1]' # Right Dirichlet conditions
    prob = ODEProblem(
        ODEFunction(burgers!, mass_matrix = [B_l; R; B_r]), 
        u0, (0.0, 1.0), 
        (D₁, D₂, R, 1e-2, similar(u0[2:end-1]))
    )

    return x₂, prob
end
```

Reference solution using Rodas5 is below:

```julia
n = 128 # Number of Chebyshev points
xs, prob = make_burgers(n)
@time sol = solve(prob, Rodas5(), reltol = 1e-12, abstol = 1e-12)

tslices = LinRange(prob.tspan..., 50)
ys = mapreduce(sol, hcat, t)
heatmap(xs, tslices, ys')
```

## Work-Precision Diagrams

```julia
test_sol = TestSolution(sol); # Reference solution for error estimation

abstols = 0.1 .^ (5:8) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:4)
multipliers = 0.5 .^ (0:3)
setups = [
    Dict(:alg => Rodas3(), :dts => 1e-4 * multipliers),
    Dict(:alg => Rodas4(), :dts => 1e-4 * multipliers),
    Dict(:alg => Rodas5(), :dts => 1e-4 * multipliers),
    Dict(:alg => GRK4T(), :dts => 1e-4 * multipliers),
    Dict(:alg => GRK4A(), :dts => 1e-4 * multipliers),
]
labels = hcat(
    "Rodas3",
    "Rodas4",
    "Rodas5",
    "GRK4T",
    "GRK4A",
)

@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Inf);

plot(wp, label=labels, 
    markershape=:auto, title="Work-Precision Diagram",
    legend=:topright, size=(800, 600))
```


```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
