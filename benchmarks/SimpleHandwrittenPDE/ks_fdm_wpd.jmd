---
title: Kuramoto-Sivashinsky Finite-Difference Method Work-Precision Diagrams
author: Arjit Seth
---

```julia
using OrdinaryDiffEq
using DiffEqDevTools
using SciMLOperators
using LinearSolve
using LinearAlgebra
using SparseArrays
using Plots
gr();
```

The Kuramoto-Sivashinsky equation is considered with the following initial and periodic boundary conditions:
```math
\begin{align}
    \partial_t u + \partial_x^2 u + \partial_x^4 u
    + \alpha \partial_x (u \partial_x u) & = 0 \\
    u(0,x) & = \cos\left(\frac{2\pi}{L} x\right), \quad \text{for } x \in [0, L] \\
    u(t,0) & = u(t,L) = 1
\end{align}
```
The derivatives are discretized via finite differences, incorporating the periodic boundary conditions.

```julia
# Linear term: second and fourth derivatives
function linear_term(N, dx, alpha)
    # Second derivative operator (-u_xx)
    e = ones(N + 1)
    D2 = spdiagm(1 => e[1:end-1], 0 => -2e, -1 => e[1:end-1])
    D2[1, end] = 1.0 # Left ghost cell
    D2[end, 1] = 1.0 # Right ghost cell
    D2 /= dx^2 # Central difference

    # Fourth derivative operator (-u_xxxx)
    D4 = D2 * D2

    mu, nu = 1, 1 # Operator coefficients

    return -alpha * (mu * D2 + nu * D4)
end


function nonlinear_term(N, dx, alpha)
    # First derivative operator
    e = ones(N)
    D1 = spdiagm(1 => e, -1 => -e)
    D1[1, end] = -1 # Left ghost cell
    D1[end, 1] = 1  # Right ghost cell
    D1 /= 2dx # Central difference

    # Nonlinear convection term (-u * u_x)
    function (du, u, p, t)
        mul!(du, D1, u)
        @. du *= -alpha * u
    end
end

# Construct the problem
function kuramoto_sivashinsky(N, L, alpha)
    x = LinRange(0, L, N + 1)
    dx = x[2] - x[1]

    f1 = linear_term(N, dx, alpha)
    f2 = nonlinear_term(N, dx, alpha)

    u0 = @. cos((2Ï€ / L) * x) # Initial condition
    prob = SplitODEProblem(MatrixOperator(f1), f2, u0, (0.0, 1.0))

    return x, prob
end;
```

Reference solution using an adaptive timestepping method with high precision:

```julia
N = 128  # Number of grid points
L = 32.0  # Domain length
alpha = 50.0 # Lipschitz constant scaling factor
xs, prob = kuramoto_sivashinsky(N, L, alpha)
@time sol = solve(prob, RadauIIA5(autodiff=false); abstol=1e-14, reltol=1e-14, adaptive=true)

tslices = LinRange(0.0, 1.0, 50)
ys = mapreduce(sol, hcat, tslices)
plt = heatmap(xs, tslices, ys', xlabel="x", ylabel="t")
```

## Work-Precision Diagrams


```julia
test_sol = TestSolution(sol); # Reference solution for error estimation

abstols = 0.1 .^ (5:9) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:5)
multipliers = 0.5 .^ (0:4)
setups = [
    Dict(:alg => IMEXEuler(), :dts => 1e-4 * multipliers), 
    Dict(:alg => CNAB2(), :dts => 1e-4 * multipliers),
    Dict(:alg => CNLF2(), :dts => 1e-4 * multipliers),
    Dict(:alg => ETDRK2(), :dts => 1e-4 * multipliers),
    Dict(:alg => SBDF2(), :dts => 1e-4 * multipliers)
]
labels = hcat(
    "IMEXEuler", 
    "CNAB2",
    "CNLF2",
    "ETDRK2",
    "SBDF2",
)

@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Inf);

plot(wp, label=labels, 
    markershape=:auto, title="Work-Precision Diagram",
    legend=:topright, size=(800, 600))
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
