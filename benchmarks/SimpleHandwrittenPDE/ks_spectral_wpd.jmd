---
title: Kuramoto-Sivashinsky Pseudospectral Methods Work-Precision Diagrams
author: Arjit Seth
---

```julia
using OrdinaryDiffEq
using DiffEqDevTools
using SciMLOperators
using LinearSolve
using LinearAlgebra
using SparseArrays
using DomainSets
using ApproxFun
using Plots
gr();
```

Here is the kuramoto_sivashinsky equation using Fourier spectral methods.

```julia
function nonlinear_term(dû, û, p, t)
    D1, T, Ti, u, tmp, alpha = p
    mul!(u, D1, û) # Derivative in Fourier space
    mul!(tmp, Ti, u) # Map to real space: u_x
    mul!(u, Ti, û) # Map to real space: u
    @. u *= tmp # Multiply in real space: u * u_x
    mul!(dû, T, -alpha * u) # Transform back to Fourier space
end

function kuramoto_sivashinsky(S, n)
    D1 = (ApproxFun.Derivative(S) → S)[1:n, 1:n] # First derivative
    D2 = ApproxFun.Derivative(S, 2)[1:n, 1:n] # Second derivative
    D4 = ApproxFun.Derivative(S, 4)[1:n, 1:n] # Fourth derivative
    T = ApproxFun.plan_transform(S, n) # Transform to Fourier space
    Ti = ApproxFun.plan_itransform(S, n) # Inverse transform to real space

    x = points(S, n) # Discretization
    û₀ = T * @. (cos((2π / L) * x) + 0.1 * cos((4π / L) * x)) # Initial condition

    alpha = 5.0 # Lipshitz constant scaling factor
    nu = 10.0 # Diffusion and fourth-order coefficient
    p = (D1, T, Ti, similar(û₀), similar(û₀), alpha)

    prob = SplitODEProblem(MatrixOperator(-alpha * nu * Diagonal(D4 + D2)), nonlinear_term, û₀,
                           (0.0, 1.0), p)

    return x, prob
end
```

Reference solution using Rodas5 is below:

```julia
n = 128
L = 16.0 # Domain length
S = ApproxFun.Fourier(-L..L)
xs, prob = kuramoto_sivashinsky(S, n)
T, Ti = prob.p[2:3]
@time sol = solve(prob, Rodas5(autodiff = false); reltol = 1e-12, abstol = 1e-12)

tslices = LinRange(prob.tspan..., 50)
ys = mapreduce(t -> Ti * sol(t), hcat, tslices)
heatmap(xs, tslices, ys', xlabel = "x", ylabel = "t")
```

## Work-Precision Diagrams

```julia
test_sol = TestSolution(sol); # Reference solution for error estimation

abstols = 0.1 .^ (5:9) # all fixed dt methods so these don't matter much
reltols = 0.1 .^ (1:5)
multipliers = 0.5 .^ (0:4)
setups = [
    Dict(:alg => IMEXEuler(), :dts => 1e-4 * multipliers), 
    Dict(:alg => CNAB2(), :dts => 1e-3 * multipliers),
    Dict(:alg => CNLF2(), :dts => 1e-3 * multipliers),
    Dict(:alg => ETDRK2(), :dts => 1e-3 * multipliers),
    Dict(:alg => SBDF2(), :dts => 1e-3 * multipliers)
]
labels = hcat(
    "IMEXEuler", 
    "CNAB2",
    "CNLF2",
    "ETDRK2",
    "SBDF2",
)

@time wp = WorkPrecisionSet(prob, abstols, reltols, setups;
    print_names=true, names=labels, numruns=5, error_estimate=:l2,
    save_everystep=false, appxsol=test_sol, maxiters=Inf);

plot(wp, label=labels, 
    markershape=:auto, title="Work-Precision Diagram",
    legend=:topright, size=(800, 600))
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
