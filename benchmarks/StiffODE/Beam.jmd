---
title: Beam Work-Precision Diagrams
author: Chris Rackauckas
---

```julia
using OrdinaryDiffEq, DiffEqDevTools, Sundials, Plots, ODEInterfaceDiffEq, LSODA
using LinearAlgebra, StaticArrays, RecursiveFactorization
gr()

# Beam Problem from the Bari/CWI Test Set
# Exact implementation based on the Fortran code from deTestSet
# Original source: https://github.com/cran/deTestSet/blob/master/src/Ex_beam.f

function beam!(du, u, p, t)
    # Parameters from the original Fortran implementation
    n = 40  # Number of spatial discretization points
    deltas = 1.0 / n
    nquatr = n^4
    
    # Force term - sinusoidal loading
    f = sin(t)
    
    # The Beam equation is:
    # phi_tt + beta * phi_t + phi_ssss + beta * Gamma(phi) = F(t)
    # where Gamma(phi) = phi - sin(phi) (nonlinear term)
    # Discretized using finite differences
    
    # First n variables are angles phi[i], second n are angular velocities phi_t[i]
    phi = @view u[1:n]
    phi_t = @view u[n+1:2*n]
    
    # Velocity equations: d(phi)/dt = phi_t
    du[1:n] .= phi_t
    
    # Compute phi_ssss (fourth spatial derivative) using finite differences
    # with boundary conditions phi[0] = phi[n+1] = 0
    
    # Initialize acceleration array
    phi_tt = @view du[n+1:2*n]
    
    # Interior points
    for i in 3:n-2
        # Fourth derivative approximation
        phi_ssss = (phi[i-2] - 4*phi[i-1] + 6*phi[i] - 4*phi[i+1] + phi[i+2]) * nquatr
        # Nonlinear term Gamma
        gamma_phi = phi[i] - sin(phi[i])
        # Acceleration equation (with beta = 0.01 damping from original)
        phi_tt[i] = -phi_ssss - 0.01 * gamma_phi + f
    end
    
    # Boundary conditions
    # i = 1: use phi[0] = 0
    phi_ssss = (6*phi[1] - 4*phi[2] + phi[3]) * nquatr
    gamma_phi = phi[1] - sin(phi[1])
    phi_tt[1] = -phi_ssss - 0.01 * gamma_phi + f
    
    # i = 2: use phi[0] = 0
    phi_ssss = (-4*phi[1] + 6*phi[2] - 4*phi[3] + phi[4]) * nquatr
    gamma_phi = phi[2] - sin(phi[2])
    phi_tt[2] = -phi_ssss - 0.01 * gamma_phi + f
    
    # i = n-1: use phi[n+1] = 0
    phi_ssss = (phi[n-3] - 4*phi[n-2] + 6*phi[n-1] - 4*phi[n]) * nquatr
    gamma_phi = phi[n-1] - sin(phi[n-1])
    phi_tt[n-1] = -phi_ssss - 0.01 * gamma_phi + f
    
    # i = n: use phi[n+1] = 0
    phi_ssss = (phi[n-2] - 4*phi[n-1] + 6*phi[n]) * nquatr
    gamma_phi = phi[n] - sin(phi[n])
    phi_tt[n] = -phi_ssss - 0.01 * gamma_phi + f
end

# Initial conditions (from original Fortran)
n = 40
u0 = zeros(2*n)

# Time span (from test set - often run to t=π)
tspan = (0.0, π)

prob = ODEProblem{true, SciMLBase.FullSpecialize}(beam!, u0, tspan)
probstatic = ODEProblem{false}(beam!, SVector{80}(u0), tspan)

# Generate reference solution
sol = solve(prob, CVODE_BDF(), abstol=1/10^12, reltol=1/10^12)
sol2 = solve(probstatic, Rodas5P(), abstol=1/10^12, reltol=1/10^12)
probs = [prob, probstatic]
test_sol = [sol, sol2]

abstols = 1.0 ./ 10.0 .^ (4:11)
reltols = 1.0 ./ 10.0 .^ (1:8)
```

```julia
# Plot the beam deflection at different times
plot(sol, vars=1:5:40, labels=["x=$(i/40)" for i in 1:5:40], 
     xlabel="Time", ylabel="Angle φ", title="Beam Deflection")
```

```julia
# Plot the angular velocity distribution
plot(sol, vars=41:5:80, labels=["v at x=$(i/40)" for i in 1:5:40],
     xlabel="Time", ylabel="Angular velocity", title="Beam Angular Velocities")
```

## Omissions

Some methods may struggle with this large stiff system due to the high dimensionality and strong coupling.

```julia
# Methods that typically have issues with large stiff systems
setups = [
#Dict(:alg=>ROCK2()),
#Dict(:alg=>ROCK4())
]
```

## High Tolerances

This is the speed when you just want the answer.

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4)
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>lsoda())]
names = ["Rosenbrock23" "Rosenbrock23 Static" "KenCarp4" "TRBDF2" "KenCarp3" "lsoda"]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;names=names, verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Medium Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (6:9)
reltols = 1.0 ./ 10.0 .^ (3:6)

setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>KenCarp4(), :prob_choice => 2),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Timeseries Errors

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4)
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;error_estimate=:l2, verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Low Tolerances

This is the speed at lower tolerances, measuring what's good when accuracy is needed.

```julia
abstols = 1.0 ./ 10.0 .^ (7:10)
reltols = 1.0 ./ 10.0 .^ (4:7)

setups = [Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>Rodas4()),
          Dict(:alg=>Rodas4(), :prob_choice => 2),
          Dict(:alg=>lsoda()),
]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
setups = [Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>KenCarp4(), :prob_choice => 2),
          Dict(:alg=>Rodas4()),
          Dict(:alg=>Rodas4(), :prob_choice => 2),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Conclusion

The Beam problem demonstrates the exact formulation from the Bari/CWI test set, modeling the nonlinear dynamics of a flexible beam under sinusoidal loading. The 80-dimensional system represents spatial discretization of the beam equation with fourth-order spatial derivatives and nonlinear terms. The stiffness arises from the high-order spatial discretization (n^4 scaling) combined with the nonlinear sin(φ) terms. At high tolerances, `Rosenbrock23` and `lsoda` perform well. For higher precision, `CVODE_BDF` and `KenCarp4` show good performance, with static array versions providing efficiency gains.

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```