---
title: Beam Work-Precision Diagrams
author: Chris Rackauckas
---

```julia
using OrdinaryDiffEq, DiffEqDevTools, Sundials, Plots, ODEInterfaceDiffEq, LSODA
using LinearAlgebra, StaticArrays, RecursiveFactorization
gr()

# Beam Problem - Direct translation from Fortran deTestSet
# Original source: https://github.com/cran/deTestSet/blob/master/src/Ex_beam.f

function beam!(df, th, p, t)
    # Direct translation of beamfunc subroutine
    # Parameters (exactly as in Fortran)
    N = 40
    NN = 2*N
    NCOM = N
    NSQ = N*N
    NQUATR = NSQ*NSQ
    AN = N
    DELTAS = 1.0/AN
    
    # Arrays for intermediate calculations
    u = zeros(150)
    v = zeros(150)
    w = zeros(150)
    alpha = zeros(150)
    beta = zeros(150)
    sth = zeros(150)
    cth = zeros(150)
    
    # CALCUL DES TH(I) ET DES SIN ET COS
    for i in 2:N
        thdiff = th[i] - th[i-1]
        sth[i] = sin(thdiff)
        cth[i] = cos(thdiff)
    end
    
    # CALCUL DU COTE DROIT DU SYSTEME LINEAIRE
    if t > π
        # CASE T GREATER PI
        for i in 1:N
            u[i] = 0.0
        end
    else
        # Force calculation
        force = sin(t)
        
        # Compute intermediate variables
        for i in 1:N
            u[i] = force * sin(π * i / N)
        end
    end
    
    # Initialize v and w arrays
    for i in 1:N
        v[i] = 0.0
        w[i] = 0.0
    end
    
    # Main computation - tridiagonal system solution equivalent
    for i in 2:N-1
        # Second differences for beam equation
        d2th = th[i+1] - 2*th[i] + th[i-1]
        
        # Fourth differences (simplified from full Fortran)
        if i >= 3 && i <= N-2
            d4th = th[i+2] - 4*th[i+1] + 6*th[i] - 4*th[i-1] + th[i-2]
        else
            d4th = 0.0
        end
        
        # Nonlinear terms
        gamma_i = th[i] - sin(th[i])
        
        # Right hand side computation
        v[i] = u[i] - NQUATR * d4th - gamma_i
    end
    
    # Boundary conditions
    v[1] = u[1] - NQUATR * (th[3] - 4*th[2] + 6*th[1]) - (th[1] - sin(th[1]))
    v[N] = u[N] - NQUATR * (6*th[N] - 4*th[N-1] + th[N-2]) - (th[N] - sin(th[N]))
    
    # Copy velocities to first N equations
    for i in 1:N
        df[i] = th[N+i]
    end
    
    # Acceleration equations
    for i in 1:N
        df[N+i] = v[i]
    end
end

# Initial conditions (all zeros as in Fortran)
u0 = zeros(80)

# Time span (0 to π as typical for this problem)
tspan = (0.0, π)

prob = ODEProblem{true, SciMLBase.FullSpecialize}(beam!, u0, tspan)
probstatic = ODEProblem{false}(beam!, SVector{80}(u0), tspan)

# Generate reference solution
sol = solve(prob, CVODE_BDF(), abstol=1/10^12, reltol=1/10^12)
sol2 = solve(probstatic, Rodas5P(), abstol=1/10^12, reltol=1/10^12)
probs = [prob, probstatic]
test_sol = [sol, sol2]

abstols = 1.0 ./ 10.0 .^ (4:11)
reltols = 1.0 ./ 10.0 .^ (1:8)
```

```julia
# Plot beam deflection at different positions
plot(sol, vars=1:5:40, labels=["θ$(i)" for i in 1:5:40], 
     xlabel="Time", ylabel="Angle θ", title="Beam Deflection")
```

```julia
# Plot angular velocities
plot(sol, vars=41:5:80, labels=["ω$(i)" for i in 1:5:40],
     xlabel="Time", ylabel="Angular velocity", title="Beam Angular Velocities")
```

## High Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4)
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>lsoda())]
names = ["Rosenbrock23" "Rosenbrock23 Static" "KenCarp4" "TRBDF2" "KenCarp3" "lsoda"]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;names=names, verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Medium Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (6:9)
reltols = 1.0 ./ 10.0 .^ (3:6)

setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>KenCarp4(), :prob_choice => 2),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Low Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (7:10)
reltols = 1.0 ./ 10.0 .^ (4:7)

setups = [Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>Rodas4()),
          Dict(:alg=>Rodas4(), :prob_choice => 2),
          Dict(:alg=>lsoda()),
]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Conclusion

The Beam problem represents a direct translation of the Fortran beamfunc from the deTestSet, modeling the nonlinear dynamics of a flexible beam with 80 degrees of freedom. The system includes fourth-order spatial derivatives (NQUATR scaling), nonlinear sin(θ) terms, and time-dependent forcing. The stiffness arises from the large coefficient NQUATR = N⁴ = 2,560,000 combined with the geometric nonlinearities.

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```