---
title: Ring Modulator Work-Precision Diagrams
author: Chris Rackauckas
---

```julia
using OrdinaryDiffEq, DiffEqDevTools, Sundials, Plots, ODEInterfaceDiffEq, LSODA
using LinearAlgebra, StaticArrays, RecursiveFactorization
gr()

# Ring Modulator Problem - Direct translation from Fortran deTestSet
# Original source: https://github.com/cran/deTestSet/blob/master/src/Ex_ring.f
# Direct translation of ringfunc subroutine

function ring_modulator!(du, u, p, t)
    # Parameters from the original Fortran implementation
    c = 1.6e-8
    cs = 2e-12  
    cp = 1e-8
    r = 25000.0
    rp = 50.0
    lh = 4.45
    ls1 = 2e-7
    ls2 = 5e-8
    ls3 = 5e-8
    rg1 = 36.0
    rg2 = 17.5
    rg3 = 17.5
    ri = 5e-7
    rc = 5e-8
    gamma = 40.67286402e-9
    delta = 17.7493332
    
    # Input signals (exact from Fortran)
    pi = 3.141592653589793
    uin1 = 0.5 * sin(2000.0 * pi * t)
    uin2 = 2.0 * sin(20000.0 * pi * t)
    
    # Intermediate voltage calculations
    ud1 = u[3] - u[5] - u[7] + uin2
    ud2 = -u[4] + u[6] + u[8] + uin2  
    ud3 = -u[3] + u[5] - u[9] - uin2
    ud4 = u[4] - u[6] + u[10] - uin2
    
    # Diode currents with overflow protection (from Fortran)
    if delta * ud1 > 700.0
        qud1 = gamma * exp(700.0)
    elseif delta * ud1 < -700.0  
        qud1 = -gamma
    else
        qud1 = gamma * (exp(delta * ud1) - 1.0)
    end
    
    if delta * ud2 > 700.0
        qud2 = gamma * exp(700.0)
    elseif delta * ud2 < -700.0
        qud2 = -gamma  
    else
        qud2 = gamma * (exp(delta * ud2) - 1.0)
    end
    
    if delta * ud3 > 700.0
        qud3 = gamma * exp(700.0)
    elseif delta * ud3 < -700.0
        qud3 = -gamma
    else  
        qud3 = gamma * (exp(delta * ud3) - 1.0)
    end
    
    if delta * ud4 > 700.0
        qud4 = gamma * exp(700.0) 
    elseif delta * ud4 < -700.0
        qud4 = -gamma
    else
        qud4 = gamma * (exp(delta * ud4) - 1.0)
    end
    
    # The 15 differential equations (exact from Fortran ringfunc)
    du[1] = (uin1 - rg1 * u[1] - u[2]) / ls1
    du[2] = (u[1] - u[3] - rp * u[2]) / lh  
    du[3] = (-u[2] + u[11] - rg2 * u[3]) / ls2
    du[4] = (-u[12] - rg3 * u[4]) / ls3
    du[5] = (-qud1 + qud3) / cs
    du[6] = (qud2 - qud4) / cs  
    du[7] = (-qud1 - qud3) / cs
    du[8] = (qud2 + qud4) / cs
    du[9] = (qud3 - qud1) / cs
    du[10] = (-qud4 - qud2) / cs
    du[11] = (u[3] - u[13] - r * u[11]) / c
    du[12] = (u[4] - u[14] - r * u[12]) / c  
    du[13] = (u[11] - u[15] - rp * u[13]) / cp
    du[14] = (u[12] - rp * u[14]) / cp
    du[15] = (u[13] - rp * u[15]) / cp
end

# Initial conditions (from original Fortran - all zeros)
u0 = zeros(15)

# Time span (from test set - often run to t=0.001)
tspan = (0.0, 0.001)

prob = ODEProblem{true, SciMLBase.FullSpecialize}(ring_modulator!, u0, tspan)
probstatic = ODEProblem{false}(ring_modulator!, SVector{15}(u0), tspan)

# Generate reference solution
sol = solve(prob, CVODE_BDF(), abstol=1/10^14, reltol=1/10^14)
sol2 = solve(probstatic, Rodas5P(), abstol=1/10^14, reltol=1/10^14)
probs = [prob, probstatic]
test_sol = [sol, sol2]

abstols = 1.0 ./ 10.0 .^ (4:11)
reltols = 1.0 ./ 10.0 .^ (1:8)
```

```julia
plot(sol, vars=[1,2,3,11,12], labels=["I1" "I2" "I3" "U11" "U12"])
```

```julia
plot(sol, vars=[5,6,7,8,9,10], labels=["U5" "U6" "U7" "U8" "U9" "U10"])
```

```julia
# Plot the final output voltage
plot(sol, vars=[15], labels=["Output"], title="Ring Modulator Output")
```

## Omissions

The following were omitted from the tests due to convergence failures or instability with this highly nonlinear problem.

```julia
# ROCK methods don't handle the strong nonlinearity well
setups = [
#Dict(:alg=>ROCK2()),    
#Dict(:alg=>ROCK4())
]
```

## High Tolerances

This is the speed when you just want the answer.

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4)
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>rodas()),
          Dict(:alg=>radau()),
          Dict(:alg=>RadauIIA5()),
          Dict(:alg=>ROS34PW1a()),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>Kvaerno3()),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau())]
names = ["Rosenbrock23" "Rosenbrock23 Static" "Kvaerno3" "KenCarp4" "TRBDF2" "KenCarp3" "lsoda" "radau"]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;names=names, verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Medium Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (6:9)
reltols = 1.0 ./ 10.0 .^ (3:6)

setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>KenCarp5()),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>KenCarp4(), :prob_choice => 2),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>rodas()),
          Dict(:alg=>radau()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Timeseries Errors

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4)
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>rodas()),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau()),
          Dict(:alg=>RadauIIA5()),
          Dict(:alg=>ROS34PW1a()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;error_estimate=:l2, verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Low Tolerances

This is the speed at lower tolerances, measuring what's good when accuracy is needed.

```julia
abstols = 1.0 ./ 10.0 .^ (7:12)
reltols = 1.0 ./ 10.0 .^ (4:9)

setups = [Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>ddebdf()),
          Dict(:alg=>Rodas4()),
          Dict(:alg=>Rodas4(), :prob_choice => 2),
          Dict(:alg=>rodas()),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau()),
          Dict(:alg=>RadauIIA5()),
]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
setups = [Dict(:alg=>Kvaerno4()),
          Dict(:alg=>Kvaerno5()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>KenCarp47()),
          Dict(:alg=>KenCarp47(), :prob_choice => 2),
          Dict(:alg=>KenCarp5()),
          Dict(:alg=>Rodas4()),
          Dict(:alg=>Rodas4(), :prob_choice => 2),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau()),
          Dict(:alg=>ImplicitEulerExtrapolation()),
          Dict(:alg=>ImplicitEulerBarycentricExtrapolation()),
          Dict(:alg=>ImplicitHairerWannerExtrapolation()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Conclusion

The Ring Modulator problem represents the original 15-dimensional stiff ODE system from the Bari/CWI test set, modeling a nonlinear electronic circuit with diode ring modulation. The system exhibits strong stiffness due to the exponential diode characteristics and widely separated time constants in the circuit components. The input signals at 1 kHz and 10 kHz create complex frequency mixing behavior. At high tolerances, `Rosenbrock23` and `lsoda` perform well on this challenging nonlinear system. At medium tolerances, `KenCarp4` and `Rodas4` show excellent performance. For high precision circuit simulation, `radau` and the Rodas family methods are most efficient.

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```