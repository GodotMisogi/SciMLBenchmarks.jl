---
title: Ring Modulator Work-Precision Diagrams
author: Chris Rackauckas
---

```julia
using OrdinaryDiffEq, DiffEqDevTools, Sundials, Plots, ODEInterfaceDiffEq, LSODA
using LinearAlgebra, StaticArrays, RecursiveFactorization
gr()

# Ring Modulator Problem - Direct translation from Fortran deTestSet
# Original source: https://github.com/cran/deTestSet/blob/master/src/Ex_ring.f
# Direct translation of ringfunc subroutine

function ring_modulator!(du, u, p, t)
    # Direct translation of ringfunc subroutine from Ex_ring.f
    # Parameters from common block /ringcom/ (values from parameter initialization)
    c = 1.6e-8
    cs = 2e-12  
    cp = 1e-8
    r = 25000.0
    rp = 50.0
    lh = 4.45
    ls1 = 2e-7
    ls2 = 5e-8
    ls3 = 5e-8
    rg1 = 36.0
    rg2 = 17.5
    rg3 = 17.5
    ri = 5e-7
    rc = 5e-8
    gamma = 40.67286402e-9
    delta = 17.7493332
    
    # Input signals - exact from Fortran
    # uin1 = 0.5d0*sin(2d3*pi*t)
    # uin2 = 2d0*sin(2d4*pi*t)
    pi = 3.141592653589793238462643383
    uin1 = 0.5 * sin(2e3 * pi * t)
    uin2 = 2.0 * sin(2e4 * pi * t)
    
    # Intermediate voltage calculations - exact from Fortran
    # ud1 = +y(3)-y(5)-y(7)-uin2
    # ud2 = -y(4)+y(6)-y(7)-uin2  
    # ud3 = +y(4)+y(5)+y(7)+uin2
    # ud4 = -y(3)-y(6)+y(7)+uin2
    ud1 = +u[3] - u[5] - u[7] - uin2
    ud2 = -u[4] + u[6] - u[7] - uin2  
    ud3 = +u[4] + u[5] + u[7] + uin2
    ud4 = -u[3] - u[6] + u[7] + uin2
    
    # Diode currents - exact from Fortran
    # qud1 = gamma*(exp(delta*ud1)-1d0)
    # qud2 = gamma*(exp(delta*ud2)-1d0)
    # qud3 = gamma*(exp(delta*ud3)-1d0)
    # qud4 = gamma*(exp(delta*ud4)-1d0)
    qud1 = gamma * (exp(delta * ud1) - 1.0)
    qud2 = gamma * (exp(delta * ud2) - 1.0)
    qud3 = gamma * (exp(delta * ud3) - 1.0)
    qud4 = gamma * (exp(delta * ud4) - 1.0)
    
    # The 15 differential equations - exact from Fortran ringfunc
    # f(1) = (y(8)-0.5d0*y(10)+0.5d0*y(11)+y(14)-y(1)/r)/c
    # f(2) = (y(9)-0.5d0*y(12)+0.5d0*y(13)+y(15)-y(2)/r)/c
    # f(3) = (-qud1+qud3)/cs
    # f(4) = (-qud2+qud4)/cs
    # f(5) = (-qud1-qud3)/cs  
    # f(6) = (-qud2-qud4)/cs
    # f(7) = (qud1-qud3)/cs
    # f(8) = (uin1-rg1*y(1)-y(2))/ls1
    # f(9) = (uin2-rg2*y(2)-y(3))/ls2
    # f(10) = (-rg3*y(3))/ls3
    # f(11) = (y(1)-y(4)-rp*y(8))/lh
    # f(12) = (y(2)-y(5)-rp*y(9))/lh
    # f(13) = (y(2)-y(6)-rp*y(10))/lh
    # f(14) = (y(3)-y(7)-rp*y(11))/lh
    # f(15) = (y(3)-rp*y(12))/lh
    
    du[1] = (u[8] - 0.5*u[10] + 0.5*u[11] + u[14] - u[1]/r) / c
    du[2] = (u[9] - 0.5*u[12] + 0.5*u[13] + u[15] - u[2]/r) / c
    du[3] = (-qud1 + qud3) / cs
    du[4] = (-qud2 + qud4) / cs
    du[5] = (-qud1 - qud3) / cs
    du[6] = (-qud2 - qud4) / cs
    du[7] = (qud1 - qud3) / cs
    du[8] = (uin1 - rg1*u[1] - u[2]) / ls1
    du[9] = (uin2 - rg2*u[2] - u[3]) / ls2
    du[10] = (-rg3*u[3]) / ls3
    du[11] = (u[1] - u[4] - rp*u[8]) / lh
    du[12] = (u[2] - u[5] - rp*u[9]) / lh
    du[13] = (u[2] - u[6] - rp*u[10]) / lh
    du[14] = (u[3] - u[7] - rp*u[11]) / lh
    du[15] = (u[3] - rp*u[12]) / lh
end

# Initial conditions from Ex_ring.f lines 193-207 (ringsoln subroutine)
u0 = [-0.2339057358486745e-1,    # y(1)
      -0.7367485485540825e-2,    # y(2) 
       0.2582956709291169e0,     # y(3)
      -0.4064465721283450e0,     # y(4)
      -0.4039455665149794e0,     # y(5)
       0.2607966765422943e0,     # y(6)
       0.1106761861269975e0,     # y(7)
       0.2939904342435596e-6,    # y(8)
      -0.2840029933642329e-7,    # y(9)
       0.7267198267264553e-3,    # y(10)
       0.7929487196960840e-3,    # y(11)
      -0.7255283495698965e-3,    # y(12)
      -0.7941401968526521e-3,    # y(13)
       0.7088495416976114e-4,    # y(14)
       0.2390059075236570e-4]    # y(15)

# Time span (from test set - often run to t=0.001)
tspan = (0.0, 0.001)

prob = ODEProblem{true, SciMLBase.FullSpecialize}(ring_modulator!, u0, tspan)
probstatic = ODEProblem{false}(ring_modulator!, SVector{15}(u0), tspan)

# Generate reference solution
sol = solve(prob, CVODE_BDF(), abstol=1/10^14, reltol=1/10^14)
sol2 = solve(probstatic, Rodas5P(), abstol=1/10^14, reltol=1/10^14)
probs = [prob, probstatic]
test_sol = [sol, sol2]

abstols = 1.0 ./ 10.0 .^ (4:11)
reltols = 1.0 ./ 10.0 .^ (1:8)
```

```julia
plot(sol, vars=[1,2,3,11,12], labels=["I1" "I2" "I3" "U11" "U12"])
```

```julia
plot(sol, vars=[5,6,7,8,9,10], labels=["U5" "U6" "U7" "U8" "U9" "U10"])
```

```julia
# Plot the final output voltage
plot(sol, vars=[15], labels=["Output"], title="Ring Modulator Output")
```

## Omissions

The following were omitted from the tests due to convergence failures or instability with this highly nonlinear problem.

```julia
# ROCK methods don't handle the strong nonlinearity well
setups = [
#Dict(:alg=>ROCK2()),    
#Dict(:alg=>ROCK4())
]
```

## High Tolerances

This is the speed when you just want the answer.

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4)
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>rodas()),
          Dict(:alg=>radau()),
          Dict(:alg=>RadauIIA5()),
          Dict(:alg=>ROS34PW1a()),
          Dict(:alg=>lsoda()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>Kvaerno3()),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau())]
names = ["Rosenbrock23" "Rosenbrock23 Static" "Kvaerno3" "KenCarp4" "TRBDF2" "KenCarp3" "lsoda" "radau"]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;names=names, verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Medium Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (6:9)
reltols = 1.0 ./ 10.0 .^ (3:6)

setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>KenCarp5()),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>KenCarp4(), :prob_choice => 2),
          Dict(:alg=>KenCarp3()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>rodas()),
          Dict(:alg=>radau()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Timeseries Errors

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4)
setups = [Dict(:alg=>Rosenbrock23()),
          Dict(:alg=>Rosenbrock23(), :prob_choice => 2),
          Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>TRBDF2()),
          Dict(:alg=>rodas()),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau()),
          Dict(:alg=>RadauIIA5()),
          Dict(:alg=>ROS34PW1a()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;error_estimate=:l2, verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

## Low Tolerances

This is the speed at lower tolerances, measuring what's good when accuracy is needed.

```julia
abstols = 1.0 ./ 10.0 .^ (7:12)
reltols = 1.0 ./ 10.0 .^ (4:9)

setups = [Dict(:alg=>FBDF()),
          Dict(:alg=>QNDF()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>ddebdf()),
          Dict(:alg=>Rodas4()),
          Dict(:alg=>Rodas4(), :prob_choice => 2),
          Dict(:alg=>rodas()),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau()),
          Dict(:alg=>RadauIIA5()),
]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
setups = [Dict(:alg=>Kvaerno4()),
          Dict(:alg=>Kvaerno5()),
          Dict(:alg=>CVODE_BDF()),
          Dict(:alg=>KenCarp4()),
          Dict(:alg=>KenCarp47()),
          Dict(:alg=>KenCarp47(), :prob_choice => 2),
          Dict(:alg=>KenCarp5()),
          Dict(:alg=>Rodas4()),
          Dict(:alg=>Rodas4(), :prob_choice => 2),
          Dict(:alg=>lsoda()),
          Dict(:alg=>radau()),
          Dict(:alg=>ImplicitEulerExtrapolation()),
          Dict(:alg=>ImplicitEulerBarycentricExtrapolation()),
          Dict(:alg=>ImplicitHairerWannerExtrapolation()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups; verbose=false, dense=false,
                      save_everystep=false,appxsol=test_sol,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Conclusion

The Ring Modulator problem represents the original 15-dimensional stiff ODE system from the Bari/CWI test set, modeling a nonlinear electronic circuit with diode ring modulation. The system exhibits strong stiffness due to the exponential diode characteristics and widely separated time constants in the circuit components. The input signals at 1 kHz and 10 kHz create complex frequency mixing behavior. At high tolerances, `Rosenbrock23` and `lsoda` perform well on this challenging nonlinear system. At medium tolerances, `KenCarp4` and `Rodas4` show excellent performance. For high precision circuit simulation, `radau` and the Rodas family methods are most efficient.

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```